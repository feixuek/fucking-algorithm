# 动态规划之子序列问题解题模板

子序列问题是常见的算法问题，而且并不好解决。

首先，子序列问题本身就相对子串、子数组更困难一些，因为前者是不连续的序列，而后两者是连续的，就算穷举你都不一定会，更别说求解相关的算法问题了。

而且，子序列问题很可能涉及到两个字符串，比如前文[动态规划设计：最长公共子序列](./最长公共子序列.md)，如果没有一定的处理经验，真的不容易想出来。所以本文就来扒一扒子序列问题的套路，其实就有两种模板，相关问题只要往这两种思路上想，十拿九稳。

一般来说，这类问题都是让你求一个**最长子序列**，因为最短子序列就是一个字符嘛，没啥可问的。一旦涉及到子序列和最值，那几乎可以肯定，**考察的是动态规划技巧，时间复杂度一般都是 O(n^2)**。

原因很简单，你想想一个字符串，它的子序列有多少种可能？起码是指数级的吧，这种情况下，不用动态规划技巧，还想怎么着？

既然要用动态规划，那就要定义`dp`数组，找状态转移关系。我们说的两种思路模板，就是`dp`数组的定义思路。不同的问题可能需要不同的`dp`数组定义来解决。

### 一、两种思路

**1、第一种思路模板是一个一维的`dp`数组**：

```Golang
dp := make([]int, n)

for i := 1; i < n; i++ {
    for j := 0; j < i; j++ {
        dp[i] = 最值(dp[i], dp[j] + ...)
    }
}
```

举个我们写过的例子[动态规划设计：最长递增子序列](动态规划设计：最长递增子序列.md)，在这个思路中`dp`数组的定义是：

**在子数组 `array[0..i]` 中，我们要求的子序列（最长递增子序列）的长度是 `dp[i]`**。

为啥最长递增子序列需要这种思路呢？前文说得很清楚了，因为这样符合归纳法，可以找到状态转移的关系，这里就不具体展开了。

**2、第二种思路模板是一个二维的 dp 数组**：

```Golang
var dp [][]int

for i := 0; i < n; i++ {
    for j := 0; j < n; j++ {
        if arr[i] == arr[j] {
            dp[i][j] = dp[i][j] + ...
        } else {
            dp[i][j] = 最值(...)
        }
    }
}
```

这种思路运用相对更多一些，尤其是涉及两个字符串/数组的子序列，比如前文讲的[动态规划设计：最长公共子序列](动态规划系列/最长公共子序列.md)。本思路中`dp` 数组含义又分为「只涉及一个字符串」和「涉及两个字符串」两种情况。

**2.1 涉及两个字符串/数组时**（比如最长公共子序列），`dp`数组的含义如下：

**在子数组 `arr1[0..i]` 和子数组 `arr2[0..j]` 中，我们要求的子序列（最长公共子序列）长度为 `dp[i][j]`**。

**2.2 只涉及一个字符串/数组时**（比如本文要讲的最长回文子序列），dp 数组的含义如下：

**在子数组 `array[i..j]` 中，我们要求的子序列（最长回文子序列）的长度为 `dp[i][j]`**。

第一种情况可以参考这两篇旧文：「编辑距离」「公共子序列」

第二种情况可以参考[动态规划设计：最长回文子序列](./最长回文子序列.md)